name: Build and Notarize SwiftFormat for Xcode

on:
  push:
    branches: [develop, main]
  pull_request:
    branches: [develop, main]
  workflow_dispatch:

jobs:
  build-and-notarize:
    runs-on: macos-15
    
    steps:
      - name: Select Xcode version
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.3'
      
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Import Code Signing Certificate
        run: |
          # Debug: Check if secrets exist (without revealing them)
          if [ -z "${{ secrets.DEVELOPER_ID_CERTIFICATE_BASE64 }}" ]; then
            echo "ERROR: DEVELOPER_ID_CERTIFICATE_BASE64 secret is empty or not set"
            exit 1
          fi
          if [ -z "${{ secrets.DEVELOPER_ID_CERTIFICATE_PASSWORD }}" ]; then
            echo "ERROR: DEVELOPER_ID_CERTIFICATE_PASSWORD secret is empty or not set"  
            exit 1
          fi
          
          echo "Secrets are present, proceeding with certificate import..."
          
          # Create keychain
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          security set-keychain-settings -t 3600 -l build.keychain
          
          # Import certificate
          echo "${{ secrets.DEVELOPER_ID_CERTIFICATE_BASE64 }}" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "${{ secrets.DEVELOPER_ID_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k "" build.keychain
          
          # Clean up
          rm certificate.p12
          
          # Debug: List available certificates
          echo "Available signing identities:"
          security find-identity -v -p codesigning build.keychain
      
      - name: Archive SwiftFormat for Xcode App
        run: |
          ARCHIVE_PATH="build/SwiftFormatForXcode.xcarchive"
          xcodebuild \
            -project SwiftFormat.xcodeproj \
            -scheme "SwiftFormat for Xcode" \
            -configuration Release \
            -archivePath "$ARCHIVE_PATH" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Developer ID Application" \
            DEVELOPMENT_TEAM="8VQKF583ED" \
            PROVISIONING_PROFILE_SPECIFIER="" \
            archive
      
      - name: Copy and Sign App from Archive
        id: export-app
        run: |
          ARCHIVE_PATH="build/SwiftFormatForXcode.xcarchive"
          EXPORT_PATH="build/Export"
          mkdir -p "$EXPORT_PATH"
          
          # Copy app from archive
          cp -R "$ARCHIVE_PATH/Products/Applications/SwiftFormat for Xcode.app" "$EXPORT_PATH/"
          
          APP_PATH="$EXPORT_PATH/SwiftFormat for Xcode.app"
          echo "app-path=$APP_PATH" >> $GITHUB_OUTPUT
          echo "Copied app to: $APP_PATH"
          
          # Re-sign the app and all components
          echo "Re-signing app components..."
          find "$APP_PATH" -name "*.dylib" -exec codesign --force --sign "Developer ID Application" --timestamp {} \;
          find "$APP_PATH" -name "*.framework" -exec codesign --force --sign "Developer ID Application" --timestamp {} \;
          find "$APP_PATH" -name "*.appex" -exec codesign --force --sign "Developer ID Application" --timestamp {} \;
          codesign --force --sign "Developer ID Application" --timestamp --options runtime "$APP_PATH"
          
          # Verify signing
          codesign --verify --deep --strict "$APP_PATH"
          echo "App signing verified successfully"
      
      - name: Notarize App
        id: notarize
        uses: lando/notarize-action@v2
        with:
          product-path: ${{ steps.export-app.outputs.app-path }}
          appstore-connect-username: ${{ secrets.NOTARIZATION_USERNAME }}
          appstore-connect-password: ${{ secrets.NOTARIZATION_PASSWORD }}
          appstore-connect-team-id: 8VQKF583ED
          primary-bundle-id: com.nicklockwood.SwiftFormat-for-Xcode
          verbose: true
        continue-on-error: true
      
      - name: Get Notarization Logs on Failure
        if: steps.notarize.outcome == 'failure'
        run: |
          echo "Notarization failed, getting detailed logs..."
          # Get the request UUID from notarytool history
          REQUEST_UUID=$(xcrun notarytool history --team-id 8VQKF583ED --apple-id "${{ secrets.NOTARIZATION_USERNAME }}" --password "${{ secrets.NOTARIZATION_PASSWORD }}" --output-format json | jq -r '.[0].id')
          echo "Request UUID: $REQUEST_UUID"
          
          # Get detailed logs
          xcrun notarytool log "$REQUEST_UUID" --team-id 8VQKF583ED --apple-id "${{ secrets.NOTARIZATION_USERNAME }}" --password "${{ secrets.NOTARIZATION_PASSWORD }}"
          
          exit 1
      
      - name: Staple Notarization
        run: |
          # Retry stapling up to 3 times with delays
          for i in {1..3}; do
            echo "Stapling attempt $i..."
            if xcrun stapler staple "${{ steps.export-app.outputs.app-path }}"; then
              echo "Stapling successful on attempt $i"
              exit 0
            else
              if [ $i -eq 3 ]; then
                echo "Stapling failed after 3 attempts"
                exit 1
              else
                echo "Stapling attempt $i failed, waiting 30 seconds before retry..."
                sleep 30
              fi
            fi
          done
      
      - name: Zip App
        run: |
          cd "$(dirname "${{ steps.export-app.outputs.app-path }}")"
          zip -r SwiftFormat.for.Xcode.app.zip "SwiftFormat for Xcode.app"
          echo "ZIP_PATH=$(pwd)/SwiftFormat.for.Xcode.app.zip" >> $GITHUB_ENV
      
      - name: Upload App Artifact
        uses: actions/upload-artifact@v4
        with:
          path: ${{ env.ZIP_PATH }}
